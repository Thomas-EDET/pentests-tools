/*
    gcc server.c -lpthread -o server
*/
 
#include<stdio.h>
#include<string.h>    //fonction pour les chaines de caractèress
#include<stdlib.h>    //L'en-tête stdlib.h définit quatre types de variables, plusieurs macros et diverses fonctions pour l'exécution de fonctions générales
#include<sys/socket.h> //Pour l'utilisation de socket
#include<arpa/inet.h> //Pour inet_addr
#include<unistd.h>    //Les output et input
#include<pthread.h> //Pour l'utilisation des thread, processus léger
#include <inttypes.h> //Pour la communication
 
//définition des fonctions
char **get_strings(char **tableau,int n); 
void *connection_handler(void *);
char *Reservation(int new_socket);
void Consultation(int new_socket,char **array, int n);

char *ary[] = { "opera"," ", "54", "\n", "theatre"," ","141", "\n", NULL }; //Déclaration des variables en mémoire vive de manière globale.

char **get_strings(char **tableau,int n) {  //prend en entrée un tableau de tableau donc un tableau de string et la taille.
  char **strings = tableau; // Pour une itération facile
  char **to_be_returned = malloc(sizeof(char*) * 9); //utilisation de malloc pour une copie de la mémoire comme vu en cours.
  int i = 0;
  while(*strings) { //permet de retourner le tableau de string correctement et de l'utiliser pour l'envoie vers le client.
    to_be_returned[i] = malloc( sizeof(char) * strlen( *strings ) );
    strcpy( to_be_returned[i++], *strings); //utilisation de strcpy, qui permet de copier une chaine de caractère dans une autre, src vers dest.
    strings++; //on incrémente
  }
  return to_be_returned; //Le tableau de string en retour
}

void Consultation(int new_socket,char **array, int n){ //Prends en entrée la socket et le tableau définit en global
        
    char server_reply[2048] = {0}; //déclaration de variables ici on attribue 2048 octects à la variable server_reply
    int socket = new_socket;
	char messagetosend[2048] = "\nVoici la liste des spectacles:\n"; //Message pour le client
	
	int i = 0;
	char *myarray[9] = {""};
	 
         for (i = 0; i < n-1; i++) 
         	myarray[i] = array[i];
         
        
	send(socket , messagetosend , strlen(messagetosend) , 0 ); //send permet d'envoyer un message.
    char **strings = get_strings(myarray,9);
  	while(*strings) { //tant qu'il y a un des strings dans mon tableau de string on envoie les données.
  	send(socket , *strings , strlen(*strings) , 0 ); // on envoie le tableau avec les élements demandé, nom du spectacle et places.
    	strings++;
  	}
}

char *Reservation(int new_socket){ //Reservation ne prends en entrée que la socket
    int socket = new_socket; // on définit toutes les variables en locales, ceci est préférable plutôt que de tout déclarer en global.
    int arrayindexremainticket;
    int i = 0;
    int n = 9;
    int ok = 0;
    int remain_tickets;
    int tickets_substraction;
    char *tickets_substraction_char;
	char *myreservation;
    char new_remain_tickets[20];
    char server_reply1[2048] = {0};
    char server_reply2[2048] = {0};
    char messagetosend1[1024] = "Entrer le spectacle de votre choix: ";
    char messagetosend2[1024] = "Entrer le nombre de places souhaitées: ";
    
    char sucess[1024] = "Réservation terminée, merci et à bientôt.";
    char failed[1024] = "Réservation échoué.";
    
    send(socket , messagetosend1 , strlen(messagetosend1) , 0); // Demande du spectacle que souhaite le client
    
    recv(socket, server_reply1, 2048, 0);
    myreservation = server_reply1;

    send(socket , messagetosend2 , strlen(messagetosend2) , 0); // Demande du nombre de place que souhaite le client
    recv(socket, server_reply2, 2048, 0);
    tickets_substraction_char = server_reply2;
    
    for (i = 0; i < n-1; i=i+4) 
    	if (strcmp(myreservation,ary[i]) == 0 && (strlen(myreservation) > 2)){ // vérification de l'entrée utilisateur.
    	ok = 1;
    	arrayindexremainticket = i+2;
    	printf("Nombre de places disponibles:%s\n",ary[arrayindexremainticket]);
    	sscanf(ary[arrayindexremainticket], "%d", &remain_tickets);
    	sscanf(tickets_substraction_char, "%d", &tickets_substraction);
    	remain_tickets = remain_tickets - tickets_substraction; //Soustraction des places que réserve le client
 	if (remain_tickets < 0){ //si l'utilisateur souhaites plus de places qu'il n'y en a un message d'erreur lui est renvoyé.
 	ok=0;
 	printf("places restantes négatives,réservation échouée\n"); //si les places sont négatives on affiche côté server que les places sont négatives
 	}
 	if (remain_tickets > 0){ // sinon les places sont positives et le nombre de ticket est mis a jour
 	printf("places restantes positives\n");
    	sprintf(new_remain_tickets, "%d", remain_tickets);
    	ary[arrayindexremainticket] = new_remain_tickets;
	}
	
    	}
    	
    if (ok == 1){
    send(socket , sucess , strlen(sucess) , 0); //Envoie du message de succes ou d'échec
    return ary[2] = new_remain_tickets;
    }
    else{
    send(socket , failed , strlen(failed) , 0);
    }
    	
    
}

/*
 * Connection handler est utilisé à chaque fois qu'un client se connecte
 * */
void *connection_handler(void *socket_desc)
{
    //obtention du descripteur de socket
    int sock = *(int*)socket_desc;
    int read_size;
    char *message , client_message[2000];
     
    
     
    //Obtenir le message du client tant que c'est vrai.
    while( (read_size = recv(sock , client_message , 2000 , 0)) > 0 )
    {
        	
        	if (strcmp(client_message,"1") == 0) //si le message du client = 1 on rentre dans la fonction consultation
    		{
    		printf("consultation\n");
    		Consultation(sock,ary,9);
    		}
    
    		if (strcmp(client_message,"2") == 0) //si le mesage du client = 2 on rentre dans la fonction réservation
    		{
    		printf("fonction réservation places restantes:%s\n",Reservation(sock));
    		char c = 'A'; //On attribue une valeur arbitraire
    		intptr_t i= c; //Opération sur les variable afin d'obtenir une variable de type void ce qui est nécessaire du fait de la nature de pthread.
    		return *(void **)&i;
    		}
    		else{
    		printf("Waiting for client's disconnect...\n"); //Sinon le client se déconnecte
    		
    		}
		memset(client_message, 0, 2000); // Cette fonction renvoie un pointeur vers la zone de mémoire str qui est client_message
    }
     
    if(read_size == 0)
    {
        puts("Client disconnected"); //Si le thread ne reçoit rien alors il se déconnecte et le thread se coupe
        printf("%s\n",ary[0]); //Vérification et affichage des places côté serveur
        printf("%s\n",ary[2]);
		printf("%s\n",ary[4]);
		printf("%s\n",ary[6]);
        close(sock);
        fflush(stdout);
    }
    else if(read_size == -1)
    {
        perror("recv failed");
    }
         
    return 0;
} 

int main(int argc , char *argv[])
{
    int socket_desc , client_sock , c; //déclaraction des variable
    struct sockaddr_in server , client;
     
    //Create socket
    socket_desc = socket(AF_INET , SOCK_STREAM , 0); //socket_desc = TCP
    if (socket_desc == -1) //Dans la RFC si socket_desc retourne -1 alors quelque chose s'est mal passé
    {
        printf("Could not create socket");
    }
    puts("Socket created"); //sinon c'est que c'est bon
     
    //Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY; //Ecoute vers 0.0.0.0 donc vers * tout
    server.sin_port = htons( 7777 ); //Sur le port 7777
     
    //Bind
    if( bind(socket_desc,(struct sockaddr *)&server , sizeof(server)) < 0) //vérification de la création de socket
    {
        //print the error message
        perror("bind failed. Error"); //Ici perror est utilisé et permet d'afficher une réponse plus précise si la liaison à échouée.
        return 1; //on retourne 1 si ça s'est mal passé, c'est une convention.
    }
    puts("bind done"); //Sinon c'est que ça s'est bien passé.
     
    //Listen
    listen(socket_desc , 3); //On limite à trois connexions simultanées
     
    
    c = sizeof(struct sockaddr_in); //On accepte les connexion entrantes
    puts("Waiting for incoming connections...");
    c = sizeof(struct sockaddr_in);
	pthread_t thread_id;
	
    while( (client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c)) ) //dès qu'un client se connecte les instructions sont réalisées.
    {
    	
        puts("Connection accepted");
         
        if( pthread_create( &thread_id , NULL ,  connection_handler , (void*) &client_sock) < 0)
        {
            perror("could not create thread");
            return 1;
        }
         
        //Now join the thread , so that we dont terminate before the thread
        //pthread_join( thread_id , NULL);
        puts("Handler assigned");
    }
     
    if (client_sock < 0) //Comme avant, si le descripteur est plus n'est pas = 0 alors quelque chose s'est mal passé, on affiche l'erreur
    {
        perror("accept failed");
        return 1;
    }
    	char result;
    	intptr_t i; //intptr_t est un type entier signé optionnel pouvant représenter une adresse. Cela signifie uniquement qu'on peut convertir une adresse void * en intptr_t et que si on convertit la valeur ainsi obtenue en void *, on retrouve une adresse égale à l'adresse void * d'origine.
    	pthread_join(thread_id, (void **) &i); //pthread_join est utile pour mettre à jour la variable globale contenant les spectacles après un réservation
    	result = i;
     
    return 0;
}
 


